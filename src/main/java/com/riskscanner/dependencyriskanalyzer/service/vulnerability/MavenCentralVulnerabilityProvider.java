package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilitySource;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VersionRange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

/**
 * Maven Central vulnerability provider.
 *
 * <p>Queries Maven Central metadata for basic vulnerability information.
 * This provider extracts vulnerability data that's available in package
 * metadata, which is typically limited but provides offline capability.
 */
@Component
public class MavenCentralVulnerabilityProvider implements VulnerabilityProvider {

    private static final Logger logger = LoggerFactory.getLogger(MavenCentralVulnerabilityProvider.class);
    
    private static final String MAVEN_CENTRAL_SEARCH_API = "https://search.maven.org/solrsearch/select";
    private static final String MAVEN_CENTRAL_BASE = "https://repo.maven.apache.org/maven2";
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    public MavenCentralVulnerabilityProvider() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }
    
    @Override
    public VulnerabilitySource getSource() {
        return VulnerabilitySource.MAVEN_CENTRAL;
    }
    
    @Override
    public List<Vulnerability> getVulnerabilities(DependencyCoordinate dependency) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // First, try to get package metadata
            PackageMetadata metadata = getPackageMetadata(dependency);
            if (metadata == null) {
                logger.debug("No metadata found for dependency: {}", dependency);
                return vulnerabilities;
            }
            
            // Look for vulnerability indicators in metadata
            vulnerabilities.addAll(extractVulnerabilitiesFromMetadata(dependency, metadata));
            
            // Try to get security advisories from Maven Central (if available)
            vulnerabilities.addAll(getSecurityAdvisories(dependency));
            
            logger.info("Found {} vulnerabilities from Maven Central for {}", vulnerabilities.size(), dependency);
            
        } catch (Exception e) {
            logger.error("Failed to query Maven Central for dependency {}: {}", dependency, e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    @Override
    public boolean supportsOffline() {
        return true; // Can work with cached metadata
    }
    
    @Override
    public int getPriority() {
        return 8; // Low priority - limited vulnerability data
    }
    
    @Override
    public boolean isHealthy() {
        try {
            // Simple health check - try to query a known package
            String testUrl = MAVEN_CENTRAL_SEARCH_API + "?q=g:org.apache.commons+a:commons-lang3&rows=1&wt=json";
            String response = restTemplate.getForObject(testUrl, String.class);
            return response != null && response.contains("response");
        } catch (Exception e) {
            logger.debug("Maven Central health check failed: {}", e.getMessage());
            return false;
        }
    }
    
    @Override
    public String getDescription() {
        return "Maven Central metadata provider with basic vulnerability information from package descriptors";
    }
    
    /**
     * Gets package metadata from Maven Central.
     */
    private PackageMetadata getPackageMetadata(DependencyCoordinate dependency) {
        try {
            // Build Maven Central search query
            String query = String.format("g:%s+AND+a:%s", dependency.groupId(), dependency.artifactId());
            String searchUrl = String.format("%s?q=%s&rows=10&wt=json", MAVEN_CENTRAL_SEARCH_API, query);
            
            logger.debug("Querying Maven Central metadata for: {}", dependency);
            
            String response = restTemplate.getForObject(searchUrl, String.class);
            if (response != null) {
                JsonNode responseNode = objectMapper.readTree(response);
                JsonNode docsNode = responseNode.path("response").path("docs");
                
                if (docsNode.isArray() && docsNode.size() > 0) {
                    // Use the latest version's metadata
                    JsonNode latestDoc = docsNode.get(0);
                    return parsePackageMetadata(latestDoc, dependency);
                }
            }
            
        } catch (Exception e) {
            logger.debug("Failed to get package metadata for {}: {}", dependency, e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Parses package metadata from Maven Central response.
     */
    private PackageMetadata parsePackageMetadata(JsonNode docNode, DependencyCoordinate dependency) {
        try {
            String groupId = docNode.path("g").asText();
            String artifactId = docNode.path("a").asText();
            String version = docNode.path("latestVersion").asText();
            Instant updated = Instant.parse(docNode.path("timestamp").asText() + "Z");
            
            // Look for security-related tags in the description
            String description = docNode.path("description").asText("");
            boolean hasSecurityIndicators = containsSecurityIndicators(description);
            
            return new PackageMetadata(groupId, artifactId, version, description, updated, hasSecurityIndicators);
            
        } catch (Exception e) {
            logger.debug("Failed to parse package metadata: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Extracts vulnerabilities from package metadata.
     */
    private List<Vulnerability> extractVulnerabilitiesFromMetadata(DependencyCoordinate dependency, PackageMetadata metadata) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        // Maven Central doesn't provide structured vulnerability data
        // We can only infer potential issues from metadata
        
        if (metadata.hasSecurityIndicators()) {
            // Create a generic vulnerability entry for packages with security indicators
            Vulnerability vulnerability = Vulnerability.builder()
                .id("MAVEN-CENTRAL-" + dependency.groupId() + ":" + dependency.artifactId())
                .source(VulnerabilitySource.MAVEN_CENTRAL)
                .title("Potential security issues detected")
                .description("Package metadata contains security-related keywords. Manual review recommended.")
                .severity(Severity.LOW) // Low severity since this is just an indicator
                .affectedVersions(List.of(dependency.version()))
                .publishedAt(metadata.getUpdated())
                .updatedAt(metadata.getUpdated())
                .references(List.of(MAVEN_CENTRAL_BASE + "/" + 
                    dependency.groupId().replace(".", "/") + "/" + 
                    dependency.artifactId() + "/" + dependency.version()))
                .build();
            
            vulnerabilities.add(vulnerability);
        }
        
        return vulnerabilities;
    }
    
    /**
     * Gets security advisories from Maven Central (experimental).
     */
    private List<Vulnerability> getSecurityAdvisories(DependencyCoordinate dependency) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Try to access the .pom file for additional metadata
            String pomUrl = String.format("%s/%s/%s/%s/%s-%s.pom",
                MAVEN_CENTRAL_BASE,
                dependency.groupId().replace(".", "/"),
                dependency.artifactId(),
                dependency.version(),
                dependency.artifactId(),
                dependency.version());
            
            String pomContent = restTemplate.getForObject(pomUrl, String.class);
            if (pomContent != null) {
                // Look for security-related information in POM
                vulnerabilities.addAll(extractVulnerabilitiesFromPom(dependency, pomContent));
            }
            
        } catch (Exception e) {
            logger.debug("Failed to get POM file for {}: {}", dependency, e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    /**
     * Extracts vulnerabilities from POM content.
     */
    private List<Vulnerability> extractVulnerabilitiesFromPom(DependencyCoordinate dependency, String pomContent) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        // Look for security-related properties or comments
        if (containsSecurityIndicators(pomContent)) {
            Vulnerability vulnerability = Vulnerability.builder()
                .id("MAVEN-POM-" + dependency.groupId() + ":" + dependency.artifactId())
                .source(VulnerabilitySource.MAVEN_CENTRAL)
                .title("Security indicators in POM")
                .description("POM file contains security-related keywords or properties.")
                .severity(Severity.INFO) // Informational only
                .affectedVersions(List.of(dependency.version()))
                .publishedAt(Instant.now())
                .updatedAt(Instant.now())
                .build();
            
            vulnerabilities.add(vulnerability);
        }
        
        return vulnerabilities;
    }
    
    /**
     * Checks if text contains security-related indicators.
     */
    private boolean containsSecurityIndicators(String text) {
        if (text == null || text.isBlank()) {
            return false;
        }
        
        String lowerText = text.toLowerCase();
        return lowerText.contains("security") ||
               lowerText.contains("vulnerability") ||
               lowerText.contains("cve") ||
               lowerText.contains("exploit") ||
               lowerText.contains("patch") ||
               lowerText.contains("fix") ||
               lowerText.contains("advisory");
    }
    
    /**
     * Package metadata holder.
     */
    private static class PackageMetadata {
        private final String groupId;
        private final String artifactId;
        private final String version;
        private final String description;
        private final Instant updated;
        private final boolean hasSecurityIndicators;
        
        public PackageMetadata(String groupId, String artifactId, String version, 
                              String description, Instant updated, boolean hasSecurityIndicators) {
            this.groupId = groupId;
            this.artifactId = artifactId;
            this.version = version;
            this.description = description;
            this.updated = updated;
            this.hasSecurityIndicators = hasSecurityIndicators;
        }
        
        public String getGroupId() { return groupId; }
        public String getArtifactId() { return artifactId; }
        public String getVersion() { return version; }
        public String getDescription() { return description; }
        public Instant getUpdated() { return updated; }
        public boolean hasSecurityIndicators() { return hasSecurityIndicators; }
    }
}
