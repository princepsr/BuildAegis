package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilitySource;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VersionRange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

/**
 * NVD (National Vulnerability Database) vulnerability provider.
 *
 * <p>Queries the NVD API for CVE vulnerability information. NVD provides
 * comprehensive CVE data with CVSS scores, detailed analysis, and security
 * impact assessments from the US government repository.
 */
@Component
public class NvdVulnerabilityProvider implements VulnerabilityProvider {

    private static final Logger logger = LoggerFactory.getLogger(NvdVulnerabilityProvider.class);
    
    private static final String NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0";
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    public NvdVulnerabilityProvider() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }
    
    @Override
    public VulnerabilitySource getSource() {
        return VulnerabilitySource.NVD;
    }
    
    @Override
    public List<Vulnerability> getVulnerabilities(DependencyCoordinate dependency) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Build NVD search query - search by CPE (Common Platform Enumeration)
            String cpeString = buildCpeString(dependency);
            String searchUrl = NVD_API_BASE + "?cpeName=" + cpeString;
            
            logger.debug("Querying NVD for dependency: {} (CPE: {})", dependency, cpeString);
            
            // Make API request
            String response = restTemplate.getForObject(searchUrl, String.class);
            
            if (response != null) {
                JsonNode responseNode = objectMapper.readTree(response);
                JsonNode vulnerabilitiesNode = responseNode.get("vulnerabilities");
                
                if (vulnerabilitiesNode != null && vulnerabilitiesNode.isArray()) {
                    for (JsonNode vulnNode : vulnerabilitiesNode) {
                        try {
                            Vulnerability vulnerability = parseVulnerability(vulnNode, dependency);
                            if (vulnerability != null) {
                                vulnerabilities.add(vulnerability);
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to parse NVD vulnerability: {}", e.getMessage());
                        }
                    }
                }
            }
            
            logger.info("Found {} vulnerabilities from NVD for {}", vulnerabilities.size(), dependency);
            
        } catch (Exception e) {
            logger.error("Failed to query NVD for dependency {}: {}", dependency, e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    @Override
    public boolean supportsOffline() {
        return false; // NVD requires network access
    }
    
    @Override
    public int getPriority() {
        return 2; // High priority - authoritative CVE source
    }
    
    @Override
    public boolean isHealthy() {
        try {
            // Simple health check - try to query a known CVE
            String testUrl = NVD_API_BASE + "?cveId=CVE-2021-44228";
            String response = restTemplate.getForObject(testUrl, String.class);
            return response != null && !response.contains("\"error\"");
        } catch (Exception e) {
            logger.debug("NVD health check failed: {}", e.getMessage());
            return false;
        }
    }
    
    @Override
    public String getDescription() {
        return "National Vulnerability Database provider with authoritative CVE data and CVSS scores";
    }
    
    /**
     * Builds a CPE string for the given dependency.
     */
    private String buildCpeString(DependencyCoordinate dependency) {
        // CPE format: cpe:2.3:a:vendor:product:version:*:*:*:*:*:*:*:*
        // For Maven packages, we use groupId as vendor and artifactId as product
        String vendor = dependency.groupId().replace(".", "_");
        String product = dependency.artifactId();
        String version = dependency.version();
        
        return String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*:*", vendor, product, version);
    }
    
    /**
     * Parses a vulnerability from NVD API response.
     */
    private Vulnerability parseVulnerability(JsonNode vulnNode, DependencyCoordinate dependency) {
        try {
            JsonNode cveNode = vulnNode.get("cve");
            if (cveNode == null) {
                return null;
            }
            
            String id = cveNode.get("id").asText();
            
            // Extract description
            String description = "";
            JsonNode descriptionsNode = cveNode.get("descriptions");
            if (descriptionsNode != null && descriptionsNode.isArray()) {
                for (JsonNode descNode : descriptionsNode) {
                    if ("en".equals(descNode.get("lang").asText())) {
                        description = descNode.get("value").asText();
                        break;
                    }
                }
            }
            
            // Extract CVSS score and severity
            Double cvssScore = null;
            String cvssVector = null;
            Severity severity = Severity.MEDIUM;
            
            JsonNode metricsNode = cveNode.get("metrics");
            if (metricsNode != null) {
                // Try CVSS v3.1 first
                JsonNode cvss31Node = metricsNode.get("cvssMetricV31");
                if (cvss31Node != null && cvss31Node.isArray() && cvss31Node.size() > 0) {
                    JsonNode cvssDataNode = cvss31Node.get(0).get("cvssData");
                    if (cvssDataNode != null) {
                        cvssScore = cvssDataNode.get("baseScore").asDouble();
                        cvssVector = cvssDataNode.get("vectorString").asText();
                        severity = Severity.fromCvssScore(cvssScore);
                    }
                }
                
                // Fall back to CVSS v3.0
                if (cvssScore == null) {
                    JsonNode cvss30Node = metricsNode.get("cvssMetricV30");
                    if (cvss30Node != null && cvss30Node.isArray() && cvss30Node.size() > 0) {
                        JsonNode cvssDataNode = cvss30Node.get(0).get("cvssData");
                        if (cvssDataNode != null) {
                            cvssScore = cvssDataNode.get("baseScore").asDouble();
                            cvssVector = cvssDataNode.get("vectorString").asText();
                            severity = Severity.fromCvssScore(cvssScore);
                        }
                    }
                }
                
                // Fall back to CVSS v2.0
                if (cvssScore == null) {
                    JsonNode cvss20Node = metricsNode.get("cvssMetricV2");
                    if (cvss20Node != null && cvss20Node.isArray() && cvss20Node.size() > 0) {
                        JsonNode cvssDataNode = cvss20Node.get(0).get("cvssData");
                        if (cvssDataNode != null) {
                            cvssScore = cvssDataNode.get("baseScore").asDouble();
                            cvssVector = cvssDataNode.get("vectorString").asText();
                            severity = Severity.fromCvssScore(cvssScore);
                        }
                    }
                }
            }
            
            // Extract CWE ID
            String cweId = null;
            JsonNode weakenssesNode = cveNode.get("weaknesses");
            if (weakenssesNode != null && weakenssesNode.isArray()) {
                for (JsonNode weaknessNode : weakenssesNode) {
                    JsonNode descriptionNode = weaknessNode.get("description");
                    if (descriptionNode != null && descriptionNode.isArray()) {
                        for (JsonNode descNode : descriptionNode) {
                            if ("en".equals(descNode.get("lang").asText())) {
                                cweId = descNode.get("value").asText();
                                break;
                            }
                        }
                        if (cweId != null) break;
                    }
                }
            }
            
            // Extract references
            List<String> references = new ArrayList<>();
            JsonNode referencesNode = cveNode.get("references");
            if (referencesNode != null && referencesNode.isArray()) {
                for (JsonNode refNode : referencesNode) {
                    if (refNode.has("url")) {
                        references.add(refNode.get("url").asText());
                    }
                }
            }
            
            // Extract timestamps
            Instant publishedAt = null;
            Instant updatedAt = null;
            
            if (cveNode.has("published")) {
                publishedAt = Instant.parse(cveNode.get("published").asText());
            }
            
            if (cveNode.has("lastModified")) {
                updatedAt = Instant.parse(cveNode.get("lastModified").asText());
            }
            
            // Extract version information from configurations
            List<String> affectedVersions = new ArrayList<>();
            VersionRange versionRange = null;
            
            JsonNode configurationsNode = cveNode.get("configurations");
            if (configurationsNode != null && configurationsNode.isArray()) {
                for (JsonNode configNode : configurationsNode) {
                    if (isConfigurationRelevant(configNode, dependency)) {
                        extractVersionInfo(configNode, dependency, affectedVersions);
                        // NVD doesn't typically provide structured version ranges like OSV
                        // We'll rely on affected versions list
                    }
                }
            }
            
            return Vulnerability.builder()
                .id(id)
                .source(VulnerabilitySource.NVD)
                .title(id) // NVD doesn't have titles, use CVE ID
                .description(description)
                .severity(severity)
                .affectedVersions(affectedVersions)
                .versionRange(versionRange)
                .references(references)
                .aliases(List.of(id)) // CVE ID is the primary alias
                .publishedAt(publishedAt)
                .updatedAt(updatedAt)
                .cweId(cweId)
                .cvssScore(cvssScore)
                .cvssVector(cvssVector)
                .build();
                
        } catch (Exception e) {
            logger.warn("Failed to parse NVD vulnerability: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Checks if a configuration is relevant to our dependency.
     */
    private boolean isConfigurationRelevant(JsonNode configNode, DependencyCoordinate dependency) {
        JsonNode nodesNode = configNode.get("nodes");
        if (nodesNode == null || !nodesNode.isArray()) {
            return false;
        }
        
        for (JsonNode nodeNode : nodesNode) {
            if (isNodeRelevant(nodeNode, dependency)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Checks if an individual node is relevant to our dependency.
     */
    private boolean isNodeRelevant(JsonNode nodeNode, DependencyCoordinate dependency) {
        if (!"cpeMatch".equals(nodeNode.get("negate").asText("false"))) {
            JsonNode cpeMatchNode = nodeNode.get("cpeMatch");
            if (cpeMatchNode != null) {
                String cpe23Uri = cpeMatchNode.get("cpe23Uri").asText();
                return cpe23Uri.contains(dependency.groupId().replace(".", "_")) && 
                       cpe23Uri.contains(dependency.artifactId());
            }
        }
        return false;
    }
    
    /**
     * Extracts version information from configuration nodes.
     */
    private void extractVersionInfo(JsonNode configNode, DependencyCoordinate dependency, List<String> affectedVersions) {
        JsonNode nodesNode = configNode.get("nodes");
        if (nodesNode == null || !nodesNode.isArray()) {
            return;
        }
        
        for (JsonNode nodeNode : nodesNode) {
            JsonNode cpeMatchNode = nodeNode.get("cpeMatch");
            if (cpeMatchNode != null) {
                // Extract version from CPE if it contains a specific version
                String cpe23Uri = cpeMatchNode.get("cpe23Uri").asText();
                String[] cpeParts = cpe23Uri.split(":");
                if (cpeParts.length > 6) {
                    String version = cpeParts[6];
                    if (!"*".equals(version) && !"-".equals(version)) {
                        affectedVersions.add(version);
                    }
                }
            }
        }
    }
}
