package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.ConfidenceLevel;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.RiskScore;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilitySource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;
import java.util.StringJoiner;

/**
 * Service for calculating contextual risk scores and confidence levels.
 *
 * <p>Provides transparent, explainable risk assessment based on multiple factors
 * including severity, dependency characteristics, and source reliability.
 */
@Service
public class RiskScoreCalculator {

    private static final Logger logger = LoggerFactory.getLogger(RiskScoreCalculator.class);

    // Source reliability weights (higher = more reliable)
    private static final double SOURCE_WEIGHT_NVD = 1.0;
    private static final double SOURCE_WEIGHT_GITHUB = 0.9;
    private static final double SOURCE_WEIGHT_OSV = 0.8;
    private static final double SOURCE_WEIGHT_MAVEN_CENTRAL = 0.6;

    // Risk scoring weights
    private static final double SEVERITY_WEIGHT = 0.4;
    private static final double SCOPE_WEIGHT = 0.2;
    private static final double DEPTH_WEIGHT = 0.2;
    private static final double EXPLOIT_WEIGHT = 0.2;

    // Common runtime scopes
    private static final Set<String> RUNTIME_SCOPES = Set.of("compile", "runtime");
    
    // Common test scopes
    private static final Set<String> TEST_SCOPES = Set.of("test", "test-compile", "test-runtime");

    /**
     * Calculates a risk score for a vulnerability finding.
     *
     * @param vulnerability the vulnerability
     * @param dependency the affected dependency
     * @param sources list of sources confirming the vulnerability
     * @param dependencyDepth depth of dependency (0 = direct)
     * @param hasKnownExploit whether the vulnerability has known exploits
     * @return calculated risk score with explanation
     */
    public RiskScore calculateRiskScore(Vulnerability vulnerability, DependencyCoordinate dependency,
                                      List<String> sources, int dependencyDepth, boolean hasKnownExploit) {
        
        StringBuilder explanation = new StringBuilder("Risk score calculation:\n");

        // Calculate base score from severity
        int severityScore = getSeverityScore(vulnerability.getSeverity());
        double severityComponent = severityScore * SEVERITY_WEIGHT;
        explanation.append(String.format("- Severity (%s): %d × %.1f = %.1f\n", 
            vulnerability.getSeverity(), severityScore, SEVERITY_WEIGHT, severityComponent));

        // Calculate scope component
        double scopeComponent = calculateScopeComponent(dependency, explanation);

        // Calculate depth component
        double depthComponent = calculateDepthComponent(dependencyDepth, explanation);

        // Calculate exploit component
        double exploitComponent = calculateExploitComponent(hasKnownExploit, explanation);

        // Calculate total score
        double totalScore = severityComponent + scopeComponent + depthComponent + exploitComponent;
        int finalScore = (int) Math.round(totalScore);

        explanation.append(String.format("- Total risk score: %.1f → %d\n", totalScore, finalScore));

        logger.debug("Calculated risk score {} for {} in {}", finalScore, vulnerability.getId(), dependency);

        return new RiskScore(finalScore, explanation.toString());
    }

    /**
     * Calculates confidence level based on multiple factors.
     *
     * @param vulnerability the vulnerability
     * @param dependency the affected dependency
     * @param sources list of sources confirming the vulnerability
     * @param exactMatch whether the artifact match is exact
     * @param versionMatchQuality quality of version match (1.0 = exact)
     * @return confidence score (0-100) and level
     */
    public ConfidenceCalculation calculateConfidence(Vulnerability vulnerability, DependencyCoordinate dependency,
                                                   List<String> sources, boolean exactMatch, double versionMatchQuality) {
        
        int confidenceScore = 0;
        StringBuilder explanation = new StringBuilder("Confidence calculation:\n");

        // Base score from exact match
        if (exactMatch) {
            confidenceScore += 40;
            explanation.append("- Exact artifact match: +40\n");
        } else {
            confidenceScore += 20;
            explanation.append("- Fuzzy artifact match: +20\n");
        }

        // Version match quality
        int versionScore = (int) Math.round(versionMatchQuality * 30);
        confidenceScore += versionScore;
        explanation.append(String.format("- Version match quality (%.2f): +%d\n", versionMatchQuality, versionScore));

        // Source count and reliability
        int sourceScore = calculateSourceScore(sources);
        confidenceScore += sourceScore;
        explanation.append(String.format("- Source reliability: +%d\n", sourceScore));

        // Vulnerability ID format quality
        int idScore = calculateIdScore(vulnerability.getId());
        confidenceScore += idScore;
        explanation.append(String.format("- ID format quality: +%d\n", idScore));

        // Clamp to 0-100
        confidenceScore = Math.max(0, Math.min(100, confidenceScore));
        explanation.append(String.format("- Final confidence score: %d\n", confidenceScore));

        ConfidenceLevel level = ConfidenceLevel.fromScore(confidenceScore);
        explanation.append(String.format("- Confidence level: %s\n", level.getDisplayName()));

        logger.debug("Calculated confidence {} for {} in {}", level, vulnerability.getId(), dependency);

        return new ConfidenceCalculation(confidenceScore, level, explanation.toString());
    }

    /**
     * Gets numerical score for severity levels.
     */
    private int getSeverityScore(Severity severity) {
        return switch (severity) {
            case CRITICAL -> 100;
            case HIGH -> 80;
            case MEDIUM -> 60;
            case LOW -> 40;
            case INFO -> 20;
        };
    }

    /**
     * Calculates scope component of risk score.
     */
    private double calculateScopeComponent(DependencyCoordinate dependency, StringBuilder explanation) {
        String scope = dependency.scope();
        if (scope == null) {
            scope = "compile"; // Default assumption
        }

        double scopeScore;
        if (TEST_SCOPES.contains(scope.toLowerCase())) {
            scopeScore = 10; // Low risk for test dependencies
            explanation.append(String.format("- Scope (%s): %d × %.1f = %.1f\n", scope, scopeScore, SCOPE_WEIGHT, scopeScore * SCOPE_WEIGHT));
        } else if (RUNTIME_SCOPES.contains(scope.toLowerCase())) {
            scopeScore = 80; // High risk for runtime dependencies
            explanation.append(String.format("- Scope (%s): %d × %.1f = %.1f\n", scope, scopeScore, SCOPE_WEIGHT, scopeScore * SCOPE_WEIGHT));
        } else {
            scopeScore = 50; // Medium risk for other scopes
            explanation.append(String.format("- Scope (%s): %d × %.1f = %.1f\n", scope, scopeScore, SCOPE_WEIGHT, scopeScore * SCOPE_WEIGHT));
        }

        return scopeScore * SCOPE_WEIGHT;
    }

    /**
     * Calculates depth component of risk score.
     */
    private double calculateDepthComponent(int dependencyDepth, StringBuilder explanation) {
        // Direct dependencies (depth 0) are higher risk
        double depthScore = Math.max(20, 100 - (dependencyDepth * 20));
        explanation.append(String.format("- Dependency depth (%d): %.0f × %.1f = %.1f\n", 
            dependencyDepth, depthScore, DEPTH_WEIGHT, depthScore * DEPTH_WEIGHT));
        return depthScore * DEPTH_WEIGHT;
    }

    /**
     * Calculates exploit component of risk score.
     */
    private double calculateExploitComponent(boolean hasKnownExploit, StringBuilder explanation) {
        double exploitScore = hasKnownExploit ? 100 : 50;
        explanation.append(String.format("- Known exploit (%s): %.0f × %.1f = %.1f\n", 
            hasKnownExploit ? "yes" : "no", exploitScore, EXPLOIT_WEIGHT, exploitScore * EXPLOIT_WEIGHT));
        return exploitScore * EXPLOIT_WEIGHT;
    }

    /**
     * Calculates source reliability score.
     */
    private int calculateSourceScore(List<String> sources) {
        double totalWeight = 0.0;
        
        for (String source : sources) {
            try {
                VulnerabilitySource vs = VulnerabilitySource.fromDisplayName(source);
                totalWeight += switch (vs) {
                    case NVD -> SOURCE_WEIGHT_NVD;
                    case GITHUB -> SOURCE_WEIGHT_GITHUB;
                    case OSV -> SOURCE_WEIGHT_OSV;
                    case MAVEN_CENTRAL -> SOURCE_WEIGHT_MAVEN_CENTRAL;
                };
            } catch (IllegalArgumentException e) {
                // Unknown source, give minimal weight
                totalWeight += 0.3;
            }
        }

        // Normalize to 0-30 scale
        return (int) Math.min(30, Math.round(totalWeight * 10));
    }

    /**
     * Calculates ID format quality score.
     */
    private int calculateIdScore(String vulnerabilityId) {
        if (vulnerabilityId == null || vulnerabilityId.isBlank()) {
            return 0;
        }

        // CVE IDs get highest score
        if (vulnerabilityId.startsWith("CVE-")) {
            return 10;
        }
        
        // GitHub Advisory IDs get good score
        if (vulnerabilityId.startsWith("GHSA-")) {
            return 8;
        }
        
        // OSV IDs get decent score
        if (vulnerabilityId.matches("[A-Z]+-\\d{4}-\\d+")) {
            return 6;
        }
        
        // Other formats get minimal score
        return 2;
    }

    /**
     * Result of confidence calculation.
     */
    public static class ConfidenceCalculation {
        private final int score;
        private final ConfidenceLevel level;
        private final String explanation;

        public ConfidenceCalculation(int score, ConfidenceLevel level, String explanation) {
            this.score = score;
            this.level = level;
            this.explanation = explanation;
        }

        public int getScore() {
            return score;
        }

        public ConfidenceLevel getLevel() {
            return level;
        }

        public String getExplanation() {
            return explanation;
        }
    }
}
