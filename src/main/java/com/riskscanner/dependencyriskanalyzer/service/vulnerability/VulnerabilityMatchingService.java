package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.riskscanner.dependencyriskanalyzer.config.LoggingConfig;
import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityFinding;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.RiskScore;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.ConfidenceLevel;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.FalsePositiveAnalysis;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Service for matching vulnerabilities to dependencies.
 *
 * <p>This service orchestrates multiple vulnerability providers and performs
 * intelligent matching using exact version matches and version range analysis.
 * Results are cached for performance and deduplicated across providers.
 */
@Service
public class VulnerabilityMatchingService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityMatchingService.class);

    private final List<VulnerabilityProvider> providers;
    private final VulnerabilityCacheService cacheService;
    private final FalsePositiveAnalyzer falsePositiveAnalyzer;
    private final RiskScoreCalculator riskScoreCalculator;
    private final Map<String, List<Vulnerability>> memoryCache = new ConcurrentHashMap<>();

    @Autowired
    public VulnerabilityMatchingService(List<VulnerabilityProvider> providers, 
                                       VulnerabilityCacheService cacheService,
                                       FalsePositiveAnalyzer falsePositiveAnalyzer,
                                       RiskScoreCalculator riskScoreCalculator) {
        this.providers = providers.stream()
            .sorted(Comparator.comparingInt(VulnerabilityProvider::getPriority))
            .collect(Collectors.toList());
        this.cacheService = cacheService;
        this.falsePositiveAnalyzer = falsePositiveAnalyzer;
        this.riskScoreCalculator = riskScoreCalculator;
        
        logger.info("Initialized vulnerability matching service with {} providers: {}", 
            providers.size(), 
            providers.stream().map(p -> p.getSource().getDisplayName()).toList());
    }

    /**
     * Gets all vulnerabilities affecting the given dependency.
     *
     * @param dependency the dependency to check
     * @return list of vulnerabilities, ordered by severity (highest first)
     */
    public List<Vulnerability> getVulnerabilities(DependencyCoordinate dependency) {
        return getVulnerabilities(dependency, FalsePositiveAnalyzer.AnalysisContext.defaultContext());
    }

    /**
     * Gets all vulnerabilities affecting the given dependency with false positive analysis.
     *
     * @param dependency the dependency to check
     * @param analysisContext context for false positive analysis
     * @return list of vulnerabilities, ordered by severity (highest first)
     */
    public List<Vulnerability> getVulnerabilities(DependencyCoordinate dependency, 
                                                 FalsePositiveAnalyzer.AnalysisContext analysisContext) {
        // Check cache first
        List<Vulnerability> cached = cacheService.getCachedVulnerabilities(dependency);
        if (!cached.isEmpty()) {
            logger.debug("Returning cached vulnerabilities for {}", dependency);
            // Apply false positive analysis to cached results
            return applyFalsePositiveAnalysis(cached, dependency, analysisContext);
        }

        List<Vulnerability> allVulnerabilities = new ArrayList<>();
        boolean hasOfflineProviders = false;
        
        // Query all providers
        for (VulnerabilityProvider provider : providers) {
            if (provider.isHealthy()) {
                try {
                    logger.debug("Querying {} for vulnerabilities", provider.getSource().getDisplayName());
                    List<Vulnerability> providerVulns = provider.getVulnerabilities(dependency);
                    allVulnerabilities.addAll(providerVulns);
                    
                    logger.debug("Found {} vulnerabilities from {}", 
                        providerVulns.size(), provider.getSource().getDisplayName());
                        
                } catch (Exception e) {
                    logger.warn("Failed to query {} for {}: {}", 
                        provider.getSource().getDisplayName(), dependency, e.getMessage());
                }
            } else {
                logger.debug("Skipping unhealthy provider: {}", provider.getSource().getDisplayName());
                if (provider.supportsOffline()) {
                    hasOfflineProviders = true;
                }
            }
        }

        // If no online providers worked and we have offline capability, try offline providers
        if (allVulnerabilities.isEmpty() && hasOfflineProviders) {
            logger.info("No online providers available, trying offline providers for {}", dependency);
            for (VulnerabilityProvider provider : providers) {
                if (!provider.isHealthy() && provider.supportsOffline()) {
                    try {
                        logger.debug("Querying offline provider {} for vulnerabilities", provider.getSource().getDisplayName());
                        List<Vulnerability> providerVulns = provider.getVulnerabilities(dependency);
                        allVulnerabilities.addAll(providerVulns);
                        
                        logger.debug("Found {} vulnerabilities from offline provider {}", 
                            providerVulns.size(), provider.getSource().getDisplayName());
                            
                    } catch (Exception e) {
                        logger.warn("Failed to query offline provider {} for {}: {}", 
                            provider.getSource().getDisplayName(), dependency, e.getMessage());
                    }
                }
            }
        }

        // Filter and match vulnerabilities
        List<Vulnerability> matchedVulnerabilities = filterAndMatchVulnerabilities(dependency, allVulnerabilities);
        
        // Apply false positive analysis
        List<Vulnerability> analyzedVulnerabilities = applyFalsePositiveAnalysis(matchedVulnerabilities, dependency, analysisContext);
        
        // Sort by severity (highest first) and then by source priority
        analyzedVulnerabilities.sort((v1, v2) -> {
            int severityCompare = v2.getSeverity().ordinal() - v1.getSeverity().ordinal();
            if (severityCompare != 0) {
                return severityCompare;
            }
            
            // If same severity, prefer higher priority source
            int priority1 = getProviderPriority(v1.getSource());
            int priority2 = getProviderPriority(v2.getSource());
            return Integer.compare(priority1, priority2);
        });

        // Cache results (before false positive analysis to preserve original data)
        cacheService.cacheVulnerabilities(dependency, matchedVulnerabilities);
        
        logger.info("Found {} total vulnerabilities affecting {} (from {} providers)", 
            analyzedVulnerabilities.size(), dependency, 
            analyzedVulnerabilities.stream().map(v -> v.getSource().getDisplayName()).distinct().count());

        return analyzedVulnerabilities;
    }

    /**
     * Gets vulnerabilities for multiple dependencies efficiently.
     *
     * @param dependencies list of dependencies to check
     * @return map of dependency to its vulnerabilities
     */
    public Map<DependencyCoordinate, List<Vulnerability>> getVulnerabilities(List<DependencyCoordinate> dependencies) {
        return getVulnerabilities(dependencies, FalsePositiveAnalyzer.AnalysisContext.defaultContext());
    }

    /**
     * Gets vulnerabilities for multiple dependencies efficiently with false positive analysis.
     *
     * @param dependencies list of dependencies to check
     * @param analysisContext context for false positive analysis
     * @return map of dependency to its vulnerabilities
     */
    public Map<DependencyCoordinate, List<Vulnerability>> getVulnerabilities(List<DependencyCoordinate> dependencies, 
                                                                            FalsePositiveAnalyzer.AnalysisContext analysisContext) {
        Map<DependencyCoordinate, List<Vulnerability>> results = new ConcurrentHashMap<>();
        
        // Process dependencies in parallel for better performance
        dependencies.parallelStream().forEach(dependency -> {
            results.put(dependency, getVulnerabilities(dependency, analysisContext));
        });
        
        return results;
    }

    /**
     * Gets false positive analysis for vulnerabilities.
     *
     * @param vulnerabilities list of vulnerabilities to analyze
     * @param dependency the dependency containing the vulnerabilities
     * @param analysisContext context for false positive analysis
     * @return list of false positive analyses
     */
    public List<FalsePositiveAnalysis> getFalsePositiveAnalyses(List<Vulnerability> vulnerabilities, 
                                                               DependencyCoordinate dependency,
                                                               FalsePositiveAnalyzer.AnalysisContext analysisContext) {
        return falsePositiveAnalyzer.analyze(vulnerabilities, dependency, analysisContext);
    }

    /**
     * Gets vulnerability statistics for the given dependencies.
     *
     * @param dependencies list of dependencies to analyze
     * @return vulnerability statistics
     */
    public VulnerabilityStatistics getStatistics(List<DependencyCoordinate> dependencies) {
        Map<DependencyCoordinate, List<Vulnerability>> allVulns = getVulnerabilities(dependencies);
        
        int totalDependencies = dependencies.size();
        int affectedDependencies = (int) allVulns.values().stream()
            .filter(vulns -> !vulns.isEmpty())
            .count();
        
        int totalVulnerabilities = allVulns.values().stream()
            .mapToInt(List::size)
            .sum();
        
        Map<Severity, Long> severityCounts = allVulns.values().stream()
            .flatMap(List::stream)
            .collect(Collectors.groupingBy(Vulnerability::getSeverity, Collectors.counting()));
        
        Map<String, Long> sourceCounts = allVulns.values().stream()
            .flatMap(List::stream)
            .collect(Collectors.groupingBy(v -> v.getSource().getDisplayName(), Collectors.counting()));
        
        return new VulnerabilityStatistics(
            totalDependencies, affectedDependencies, totalVulnerabilities,
            severityCounts, sourceCounts
        );
    }

    /**
     * Gets vulnerability findings with risk scores and confidence levels for a single dependency.
     *
     * @param dependency the dependency to check
     * @param dependencyDepth depth of the dependency (0 = direct)
     * @param analysisContext context for false positive analysis
     * @return list of vulnerability findings with risk scores and confidence
     */
    public List<VulnerabilityFinding> getVulnerabilityFindings(DependencyCoordinate dependency, 
                                                                     int dependencyDepth, 
                                                                     FalsePositiveAnalyzer.AnalysisContext analysisContext) {
        String correlationId = LoggingConfig.CorrelationIdUtils.getCurrentCorrelationId();
        if (correlationId == null) {
            correlationId = LoggingConfig.CorrelationIdUtils.generateNewCorrelationId();
        }
        
        logger.info("correlationId={}, action=ANALYSIS_START, dependency={}, depth={}, analysisContext={}", 
            correlationId, dependency, dependencyDepth, analysisContext);
        
        long startTime = System.currentTimeMillis();
        
        try {
            // Get all vulnerabilities from multiple sources
            List<Vulnerability> allVulnerabilities = getVulnerabilities(dependency, analysisContext);
            logger.debug("correlationId={}, action=VULNERABILITIES_FOUND, count={}, sources={}", 
                correlationId, allVulnerabilities.size(), 
                allVulnerabilities.stream().map(v -> v.getSource()).distinct().toList());
            
            // Create vulnerability findings with risk scoring and confidence
            List<VulnerabilityFinding> findings = new ArrayList<>();
            
            for (Vulnerability vulnerability : allVulnerabilities) {
                try {
                    VulnerabilityFinding finding = createVulnerabilityFinding(
                        dependency, vulnerability, dependencyDepth, analysisContext);
                    findings.add(finding);
                    
                    logger.debug("correlationId={}, action=FINDING_CREATED, vulnerabilityId={}, riskScore={}, confidence={}", 
                        correlationId, vulnerability.getId(), finding.getRiskScore().getScore(), finding.getConfidenceLevel());
                        
                } catch (Exception e) {
                    logger.error("correlationId={}, action=FINDING_CREATION_ERROR, vulnerabilityId={}, error={}", 
                        correlationId, vulnerability.getId(), e.getMessage(), e);
                }
            }
            
            // Sort by risk score (highest first) and then by confidence
            findings.sort((f1, f2) -> {
                int riskCompare = Integer.compare(f2.getRiskScore().getScore(), f1.getRiskScore().getScore());
                if (riskCompare != 0) return riskCompare;
                return Integer.compare(f2.getConfidenceScore(), f1.getConfidenceScore());
            });
            
            long duration = System.currentTimeMillis() - startTime;
            logger.info("correlationId={}, action=ANALYSIS_COMPLETE, findingsCount={}, durationMs={}, riskLevels={}", 
                correlationId, findings.size(), duration, 
                findings.stream().collect(Collectors.groupingBy(f -> f.getRiskScore().getRiskLevel(), Collectors.counting())));
            
            return findings;
            
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            logger.error("correlationId={}, action=ANALYSIS_ERROR, dependency={}, durationMs={}, error={}", 
                correlationId, dependency, duration, e.getMessage(), e);
            throw new RuntimeException("Failed to analyze vulnerabilities for " + dependency, e);
        } finally {
            LoggingConfig.CorrelationIdUtils.clearCorrelationId();
        }
    }

    /**
     * Gets vulnerability findings for multiple dependencies.
     *
     * @param dependencies list of dependencies to check
     * @param dependencyDepths map of dependency to its depth
     * @param analysisContext context for false positive analysis
     * @return map of dependency to its vulnerability findings
     */
    public Map<DependencyCoordinate, List<VulnerabilityFinding>> getVulnerabilityFindings(
            List<DependencyCoordinate> dependencies,
            Map<DependencyCoordinate, Integer> dependencyDepths,
            FalsePositiveAnalyzer.AnalysisContext analysisContext) {
        
        Map<DependencyCoordinate, List<VulnerabilityFinding>> results = new ConcurrentHashMap<>();
        
        dependencies.parallelStream().forEach(dependency -> {
            int depth = dependencyDepths.getOrDefault(dependency, 0);
            results.put(dependency, getVulnerabilityFindings(dependency, depth, analysisContext));
        });
        
        return results;
    }

    /**
     * Creates a vulnerability finding with risk scoring and confidence calculation.
     */
    private VulnerabilityFinding createVulnerabilityFinding(DependencyCoordinate dependency, 
                                                              Vulnerability vulnerability, 
                                                              int dependencyDepth,
                                                              FalsePositiveAnalyzer.AnalysisContext analysisContext) {
        // Calculate confidence
        boolean exactMatch = vulnerability.affectsVersionExact(dependency.version());
        double versionMatchQuality = vulnerability.getVersionMatchQuality(dependency.version());
        List<String> sources = List.of(vulnerability.getSource().getDisplayName());
        
        RiskScoreCalculator.ConfidenceCalculation confidenceCalc = 
            riskScoreCalculator.calculateConfidence(vulnerability, dependency, sources, exactMatch, versionMatchQuality);

        // Calculate risk score
        boolean hasKnownExploit = vulnerability.getDescription().toLowerCase().contains("exploit") ||
                                 vulnerability.getReferences().stream().anyMatch(ref -> 
                                     ref.toLowerCase().contains("exploit") || ref.toLowerCase().contains("cve"));

        RiskScore riskScore = riskScoreCalculator.calculateRiskScore(
            vulnerability, dependency, sources, dependencyDepth, hasKnownExploit);

        // Create finding
        return VulnerabilityFinding.builder()
            .id(vulnerability.getId() + ":" + dependency.groupId() + ":" + dependency.artifactId())
            .dependency(dependency)
            .vulnerability(vulnerability)
            .rawSeverity(vulnerability.getSeverity())
            .riskScore(riskScore)
            .confidenceLevel(confidenceCalc.getLevel())
            .confidenceScore(confidenceCalc.getScore())
            .suppressed(false)
            .sources(sources)
            .detectedAt(java.time.Instant.now())
            .analysisNotes("Risk score: " + riskScore.getCalculationExplanation() + 
                          "\nConfidence: " + confidenceCalc.getExplanation())
            .build();
    }

    /**
     * Clears the vulnerability cache.
     */
    public void clearCache() {
        cacheService.clearCache();
        memoryCache.clear();
        logger.info("Cleared vulnerability cache");
    }

    /**
     * Gets cache statistics.
     */
    public CacheStatistics getCacheStatistics() {
        VulnerabilityCacheService.CacheStatistics cacheStats = cacheService.getCacheStatistics();
        return new CacheStatistics(
            cacheStats.getMemoryCacheEntries(),
            cacheStats.getMemoryCacheVulnerabilities(),
            cacheStats.getFileCacheEntries(),
            cacheStats.getFileCacheVulnerabilities()
        );
    }

    /**
     * Filters and matches vulnerabilities to the dependency.
     */
    private List<Vulnerability> filterAndMatchVulnerabilities(DependencyCoordinate dependency, 
                                                              List<Vulnerability> allVulnerabilities) {
        List<Vulnerability> matched = new ArrayList<>();
        
        // Deduplicate by ID (same vulnerability from multiple sources)
        Map<String, Vulnerability> deduplicated = new ConcurrentHashMap<>();
        
        for (Vulnerability vulnerability : allVulnerabilities) {
            // Check if vulnerability affects this dependency version
            if (vulnerability.affectsVersion(dependency.version())) {
                String dedupKey = vulnerability.getId();
                
                // Keep the highest severity version if duplicates exist
                Vulnerability existing = deduplicated.get(dedupKey);
                if (existing == null || vulnerability.getSeverity().ordinal() > existing.getSeverity().ordinal()) {
                    deduplicated.put(dedupKey, vulnerability);
                }
            }
        }
        
        matched.addAll(deduplicated.values());
        return matched;
    }

    /**
     * Applies false positive analysis to vulnerabilities and returns adjusted vulnerabilities.
     */
    private List<Vulnerability> applyFalsePositiveAnalysis(List<Vulnerability> vulnerabilities, 
                                                          DependencyCoordinate dependency,
                                                          FalsePositiveAnalyzer.AnalysisContext analysisContext) {
        List<FalsePositiveAnalysis> analyses = falsePositiveAnalyzer.analyze(vulnerabilities, dependency, analysisContext);
        List<Vulnerability> adjustedVulnerabilities = new ArrayList<>();
        
        for (int i = 0; i < vulnerabilities.size(); i++) {
            Vulnerability original = vulnerabilities.get(i);
            FalsePositiveAnalysis analysis = analyses.get(i);
            
            if (analysis.isDowngraded()) {
                // Create a new vulnerability with adjusted severity
                Vulnerability adjusted = Vulnerability.builder()
                    .id(original.getId())
                    .source(original.getSource())
                    .title(original.getTitle() + " [DOWNGRADED]")
                    .description(original.getDescription() + 
                        "\n\nFalse Positive Analysis: " + String.join("; ", analysis.getReasoning()) +
                        "\nOriginal severity: " + original.getSeverity() + 
                        ", Adjusted severity: " + analysis.getAdjustedSeverity())
                    .severity(analysis.getAdjustedSeverity())
                    .affectedVersions(original.getAffectedVersions())
                    .versionRange(original.getVersionRange().orElse(null))
                    .references(original.getReferences())
                    .aliases(original.getAliases())
                    .publishedAt(original.getPublishedAt())
                    .updatedAt(original.getUpdatedAt())
                    .cweId(original.getCweId().orElse(null))
                    .cvssScore(original.getCvssScore().orElse(null))
                    .cvssVector(original.getCvssVector().orElse(null))
                    .build();
                
                adjustedVulnerabilities.add(adjusted);
                logger.debug("Downgraded vulnerability {} from {} to {} for {}", 
                    original.getId(), original.getSeverity(), analysis.getAdjustedSeverity(), dependency);
            } else {
                adjustedVulnerabilities.add(original);
            }
        }
        
        return adjustedVulnerabilities;
    }

    /**
     * Builds cache key for dependency.
     */
    private String buildCacheKey(DependencyCoordinate dependency) {
        return String.format("%s:%s:%s:%s", 
            dependency.groupId(), dependency.artifactId(), 
            dependency.version(), dependency.buildTool());
    }

    /**
     * Gets provider priority for sorting.
     */
    private int getProviderPriority(com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilitySource source) {
        return providers.stream()
            .filter(p -> p.getSource() == source)
            .mapToInt(VulnerabilityProvider::getPriority)
            .findFirst()
            .orElse(Integer.MAX_VALUE);
    }

    /**
     * Vulnerability statistics holder.
     */
    public static class VulnerabilityStatistics {
        private final int totalDependencies;
        private final int affectedDependencies;
        private final int totalVulnerabilities;
        private final Map<Severity, Long> severityCounts;
        private final Map<String, Long> sourceCounts;

        public VulnerabilityStatistics(int totalDependencies, int affectedDependencies, 
                                     int totalVulnerabilities, Map<Severity, Long> severityCounts,
                                     Map<String, Long> sourceCounts) {
            this.totalDependencies = totalDependencies;
            this.affectedDependencies = affectedDependencies;
            this.totalVulnerabilities = totalVulnerabilities;
            this.severityCounts = severityCounts;
            this.sourceCounts = sourceCounts;
        }

        public int getTotalDependencies() { return totalDependencies; }
        public int getAffectedDependencies() { return affectedDependencies; }
        public int getTotalVulnerabilities() { return totalVulnerabilities; }
        public Map<Severity, Long> getSeverityCounts() { return severityCounts; }
        public Map<String, Long> getSourceCounts() { return sourceCounts; }
        
        public double getAffectedPercentage() {
            return totalDependencies > 0 ? (double) affectedDependencies / totalDependencies * 100 : 0;
        }
    }

    /**
     * Cache statistics holder.
     */
    public static class CacheStatistics {
        private final int memoryCacheEntries;
        private final int memoryCacheVulnerabilities;
        private final int fileCacheEntries;
        private final int fileCacheVulnerabilities;

        public CacheStatistics(int memoryCacheEntries, int memoryCacheVulnerabilities,
                             int fileCacheEntries, int fileCacheVulnerabilities) {
            this.memoryCacheEntries = memoryCacheEntries;
            this.memoryCacheVulnerabilities = memoryCacheVulnerabilities;
            this.fileCacheEntries = fileCacheEntries;
            this.fileCacheVulnerabilities = fileCacheVulnerabilities;
        }

        public int getMemoryCacheEntries() { return memoryCacheEntries; }
        public int getMemoryCacheVulnerabilities() { return memoryCacheVulnerabilities; }
        public int getFileCacheEntries() { return fileCacheEntries; }
        public int getFileCacheVulnerabilities() { return fileCacheVulnerabilities; }
        
        public int getTotalEntries() { return memoryCacheEntries + fileCacheEntries; }
        public int getTotalVulnerabilities() { return memoryCacheVulnerabilities + fileCacheVulnerabilities; }
    }
}
