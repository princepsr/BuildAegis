package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilityFinding;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service for managing vulnerability suppressions with audit logging.
 *
 * <p>Provides auditable suppression functionality where vulnerabilities are
 * marked as suppressed but never deleted. All suppressions are logged for
 * compliance and review purposes.
 */
@Service
public class VulnerabilitySuppressionService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilitySuppressionService.class);

    // In-memory suppression registry (could be persisted to database in production)
    private final Map<String, SuppressionRecord> suppressionRegistry = new ConcurrentHashMap<>();
    
    // Audit log of all suppression actions
    private final List<SuppressionAuditEntry> auditLog = new ArrayList<>();

    /**
     * Suppresses a vulnerability finding with audit logging.
     *
     * @param finding the vulnerability finding to suppress
     * @param reason the reason for suppression
     * @param suppressedBy who is suppressing the vulnerability
     * @param justification detailed justification for the suppression
     * @return updated finding with suppression information
     */
    public VulnerabilityFinding suppress(VulnerabilityFinding finding, String reason, String suppressedBy, String justification) {
        String suppressionKey = generateSuppressionKey(finding);
        
        // Create suppression record
        SuppressionRecord record = new SuppressionRecord(
            finding.getId(),
            finding.getDependency(),
            reason,
            suppressedBy,
            justification,
            Instant.now()
        );
        
        // Store suppression record
        suppressionRegistry.put(suppressionKey, record);
        
        // Create audit entry
        SuppressionAuditEntry auditEntry = new SuppressionAuditEntry(
            SuppressionAction.SUPPRESSED,
            finding.getId(),
            finding.getDependency(),
            reason,
            suppressedBy,
            justification,
            Instant.now()
        );
        
        synchronized (auditLog) {
            auditLog.add(auditEntry);
        }
        
        // Create updated finding with suppression info
        VulnerabilityFinding.SuppressionInfo suppressionInfo = new VulnerabilityFinding.SuppressionInfo(
            reason, suppressedBy, justification
        );
        
        VulnerabilityFinding suppressedFinding = VulnerabilityFinding.builder()
            .id(finding.getId())
            .dependency(finding.getDependency())
            .vulnerability(finding.getVulnerability())
            .rawSeverity(finding.getRawSeverity())
            .riskScore(finding.getRiskScore())
            .confidenceLevel(finding.getConfidenceLevel())
            .confidenceScore(finding.getConfidenceScore())
            .suppressed(true)
            .suppressionInfo(suppressionInfo)
            .sources(finding.getSources())
            .detectedAt(finding.getDetectedAt())
            .analysisNotes(finding.getAnalysisNotes().orElse(null))
            .build();
        
        logger.info("Suppressed vulnerability {} in {} by {}: {}", 
            finding.getId(), finding.getDependency(), suppressedBy, reason);
        
        return suppressedFinding;
    }

    /**
     * Unsupsupresses a previously suppressed vulnerability.
     *
     * @param findingId the ID of the finding to unsuppress
     * @param dependency the dependency coordinate
     * @param unsuppressedBy who is unsuppressing the vulnerability
     * @return true if successfully unsuppressed, false if not found
     */
    public boolean unsuppress(String findingId, DependencyCoordinate dependency, String unsuppressedBy) {
        String suppressionKey = generateSuppressionKey(findingId, dependency);
        
        SuppressionRecord record = suppressionRegistry.remove(suppressionKey);
        if (record == null) {
            logger.warn("No suppression found for {} in {}", findingId, dependency);
            return false;
        }
        
        // Create audit entry
        SuppressionAuditEntry auditEntry = new SuppressionAuditEntry(
            SuppressionAction.UNSUPPRESSED,
            findingId,
            dependency,
            "Unsuppressed by " + unsuppressedBy,
            unsuppressedBy,
            "Removing previous suppression",
            Instant.now()
        );
        
        synchronized (auditLog) {
            auditLog.add(auditEntry);
        }
        
        logger.info("Unsuppressed vulnerability {} in {} by {}", findingId, dependency, unsuppressedBy);
        return true;
    }

    /**
     * Checks if a vulnerability is currently suppressed.
     *
     * @param findingId the ID of the finding
     * @param dependency the dependency coordinate
     * @return true if suppressed, false otherwise
     */
    public boolean isSuppressed(String findingId, DependencyCoordinate dependency) {
        String suppressionKey = generateSuppressionKey(findingId, dependency);
        return suppressionRegistry.containsKey(suppressionKey);
    }

    /**
     * Gets the suppression record for a vulnerability.
     *
     * @param findingId the ID of the finding
     * @param dependency the dependency coordinate
     * @return suppression record if found, null otherwise
     */
    public SuppressionRecord getSuppressionRecord(String findingId, DependencyCoordinate dependency) {
        String suppressionKey = generateSuppressionKey(findingId, dependency);
        return suppressionRegistry.get(suppressionKey);
    }

    /**
     * Gets all suppression audit entries.
     *
     * @return list of audit entries
     */
    public List<SuppressionAuditEntry> getAuditLog() {
        synchronized (auditLog) {
            return new ArrayList<>(auditLog);
        }
    }

    /**
     * Gets all active suppressions.
     *
     * @return list of active suppression records
     */
    public List<SuppressionRecord> getActiveSuppressions() {
        return new ArrayList<>(suppressionRegistry.values());
    }

    /**
     * Generates a unique key for suppression tracking.
     */
    private String generateSuppressionKey(VulnerabilityFinding finding) {
        return generateSuppressionKey(finding.getId(), finding.getDependency());
    }

    /**
     * Generates a unique key for suppression tracking.
     */
    private String generateSuppressionKey(String findingId, DependencyCoordinate dependency) {
        return String.format("%s:%s:%s:%s", 
            findingId, 
            dependency.groupId(), 
            dependency.artifactId(), 
            dependency.version());
    }

    /**
     * Record of a vulnerability suppression.
     */
    public static class SuppressionRecord {
        private final String findingId;
        private final DependencyCoordinate dependency;
        private final String reason;
        private final String suppressedBy;
        private final String justification;
        private final Instant suppressedAt;

        public SuppressionRecord(String findingId, DependencyCoordinate dependency, String reason,
                               String suppressedBy, String justification, Instant suppressedAt) {
            this.findingId = findingId;
            this.dependency = dependency;
            this.reason = reason;
            this.suppressedBy = suppressedBy;
            this.justification = justification;
            this.suppressedAt = suppressedAt;
        }

        public String getFindingId() { return findingId; }
        public DependencyCoordinate getDependency() { return dependency; }
        public String getReason() { return reason; }
        public String getSuppressedBy() { return suppressedBy; }
        public String getJustification() { return justification; }
        public Instant getSuppressedAt() { return suppressedAt; }

        @Override
        public String toString() {
            return String.format("SuppressionRecord{findingId='%s', dependency=%s, reason='%s', by='%s', at=%s}",
                findingId, dependency, reason, suppressedBy, suppressedAt);
        }
    }

    /**
     * Audit entry for suppression actions.
     */
    public static class SuppressionAuditEntry {
        private final SuppressionAction action;
        private final String findingId;
        private final DependencyCoordinate dependency;
        private final String reason;
        private final String actionPerformedBy;
        private final String justification;
        private final Instant timestamp;

        public SuppressionAuditEntry(SuppressionAction action, String findingId, DependencyCoordinate dependency,
                                   String reason, String actionPerformedBy, String justification, Instant timestamp) {
            this.action = action;
            this.findingId = findingId;
            this.dependency = dependency;
            this.reason = reason;
            this.actionPerformedBy = actionPerformedBy;
            this.justification = justification;
            this.timestamp = timestamp;
        }

        public SuppressionAction getAction() { return action; }
        public String getFindingId() { return findingId; }
        public DependencyCoordinate getDependency() { return dependency; }
        public String getReason() { return reason; }
        public String getActionPerformedBy() { return actionPerformedBy; }
        public String getJustification() { return justification; }
        public Instant getTimestamp() { return timestamp; }

        @Override
        public String toString() {
            return String.format("AuditEntry{action=%s, findingId='%s', dependency=%s, by='%s', at=%s}",
                action, findingId, dependency, actionPerformedBy, timestamp);
        }
    }

    /**
     * Types of suppression actions.
     */
    public enum SuppressionAction {
        SUPPRESSED,
        UNSUPPRESSED
    }
}
