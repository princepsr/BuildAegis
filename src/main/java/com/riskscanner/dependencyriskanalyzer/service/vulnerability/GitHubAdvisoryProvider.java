package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilitySource;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VersionRange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

/**
 * GitHub Advisory Database vulnerability provider.
 *
 * <p>Queries the GitHub Advisory API for vulnerability information. GitHub
 * maintains a curated database of security advisories for open source packages
 * with focus on ecosystem-specific vulnerabilities and package metadata.
 */
@Component
public class GitHubAdvisoryProvider implements VulnerabilityProvider {

    private static final Logger logger = LoggerFactory.getLogger(GitHubAdvisoryProvider.class);
    
    private static final String GITHUB_API_BASE = "https://api.github.com/advisories";
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    public GitHubAdvisoryProvider() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }
    
    @Override
    public VulnerabilitySource getSource() {
        return VulnerabilitySource.GITHUB;
    }
    
    @Override
    public List<Vulnerability> getVulnerabilities(DependencyCoordinate dependency) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Build GitHub advisory search query
            String packageName = dependency.groupId() + ":" + dependency.artifactId();
            String ecosystem = getGitHubEcosystem(dependency.buildTool());
            
            String searchUrl = String.format("%s?ecosystem=%s&package=%s", 
                GITHUB_API_BASE, ecosystem, packageName);
            
            logger.debug("Querying GitHub Advisory for dependency: {} (ecosystem: {}, package: {})", 
                dependency, ecosystem, packageName);
            
            // Make API request
            String response = restTemplate.getForObject(searchUrl, String.class);
            
            if (response != null) {
                JsonNode responseNode = objectMapper.readTree(response);
                
                // GitHub API returns an array of advisories
                if (responseNode.isArray()) {
                    for (JsonNode advisoryNode : responseNode) {
                        try {
                            Vulnerability vulnerability = parseVulnerability(advisoryNode, dependency);
                            if (vulnerability != null) {
                                vulnerabilities.add(vulnerability);
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to parse GitHub advisory: {}", e.getMessage());
                        }
                    }
                }
            }
            
            logger.info("Found {} vulnerabilities from GitHub Advisory for {}", vulnerabilities.size(), dependency);
            
        } catch (Exception e) {
            logger.error("Failed to query GitHub Advisory for dependency {}: {}", dependency, e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    @Override
    public boolean supportsOffline() {
        return false; // GitHub Advisory requires network access
    }
    
    @Override
    public int getPriority() {
        return 3; // Medium-high priority - good coverage but less comprehensive than OSV/NVD
    }
    
    @Override
    public boolean isHealthy() {
        try {
            // Simple health check - try to query a known advisory
            String testUrl = GITHUB_API_BASE + "/GHSA-xxxx-xxxx-xxxx"; // This will 404, but tests connectivity
            restTemplate.getForObject(testUrl, String.class);
            return true; // If we get any response (even 404), the API is reachable
        } catch (Exception e) {
            logger.debug("GitHub Advisory health check failed: {}", e.getMessage());
            return false;
        }
    }
    
    @Override
    public String getDescription() {
        return "GitHub Advisory Database provider with curated open source vulnerability data";
    }
    
    /**
     * Maps build tool to GitHub ecosystem name.
     */
    private String getGitHubEcosystem(String buildTool) {
        return switch (buildTool.toLowerCase()) {
            case "maven" -> "maven";
            case "gradle" -> "maven"; // Gradle uses Maven ecosystem
            case "npm" -> "npm";
            case "pip" -> "pip";
            case "rubygems" -> "rubygems";
            case "nuget" -> "nuget";
            case "go" -> "go";
            case "rust" -> "rust";
            default -> "maven"; // Default to Maven for Java projects
        };
    }
    
    /**
     * Parses a vulnerability from GitHub Advisory API response.
     */
    private Vulnerability parseVulnerability(JsonNode advisoryNode, DependencyCoordinate dependency) {
        try {
            String ghsaId = advisoryNode.get("ghsaId").asText();
            String summary = advisoryNode.has("summary") ? advisoryNode.get("summary").asText() : ghsaId;
            String description = advisoryNode.has("description") ? advisoryNode.get("description").asText() : summary;
            
            // Extract severity
            Severity severity = extractSeverity(advisoryNode);
            
            // Extract version information
            List<String> affectedVersions = new ArrayList<>();
            VersionRange versionRange = null;
            
            JsonNode vulnerabilitiesNode = advisoryNode.get("vulnerabilities");
            if (vulnerabilitiesNode != null && vulnerabilitiesNode.isArray()) {
                for (JsonNode vulnNode : vulnerabilitiesNode) {
                    if (isVulnerabilityRelevant(vulnNode, dependency)) {
                        // Extract affected versions
                        JsonNode vulnerableVersionsNode = vulnNode.get("vulnerableVersionRange");
                        if (vulnerableVersionsNode != null) {
                            String versionRangeStr = vulnerableVersionsNode.asText();
                            versionRange = parseGitHubVersionRange(versionRangeStr);
                        }
                        
                        // Extract patched versions for reference
                        JsonNode firstPatchedNode = vulnNode.get("firstPatchedVersion");
                        if (firstPatchedNode != null && firstPatchedNode.has("identifier")) {
                            String patchedVersion = firstPatchedNode.get("identifier").asText();
                            if (patchedVersion != null && !patchedVersion.isBlank()) {
                                affectedVersions.add(patchedVersion);
                            }
                        }
                    }
                }
            }
            
            // Extract references
            List<String> references = new ArrayList<>();
            if (advisoryNode.has("permalink")) {
                references.add(advisoryNode.get("permalink").asText());
            }
            
            // Extract aliases (CVEs, etc.)
            List<String> aliases = new ArrayList<>();
            aliases.add(ghsaId); // GHSA ID is always an alias
            
            JsonNode identifiersNode = advisoryNode.get("identifiers");
            if (identifiersNode != null && identifiersNode.isArray()) {
                for (JsonNode identifierNode : identifiersNode) {
                    String type = identifierNode.get("type").asText();
                    String value = identifierNode.get("value").asText();
                    
                    if (!"GHSA".equals(type)) {
                        aliases.add(value);
                    }
                }
            }
            
            // Extract timestamps
            Instant publishedAt = null;
            Instant updatedAt = null;
            
            if (advisoryNode.has("publishedAt")) {
                publishedAt = Instant.parse(advisoryNode.get("publishedAt").asText());
            }
            
            if (advisoryNode.has("updatedAt")) {
                updatedAt = Instant.parse(advisoryNode.get("updatedAt").asText());
            }
            
            // Extract CVSS score
            Double cvssScore = null;
            String cvssVector = null;
            
            JsonNode cvssNode = advisoryNode.get("cvss");
            if (cvssNode != null) {
                if (cvssNode.has("score")) {
                    cvssScore = cvssNode.get("score").asDouble();
                }
                if (cvssNode.has("vectorString")) {
                    cvssVector = cvssNode.get("vectorString").asText();
                }
            }
            
            // Extract CWE ID
            String cweId = null;
            JsonNode cwesNode = advisoryNode.get("cwes");
            if (cwesNode != null && cwesNode.isArray() && cwesNode.size() > 0) {
                JsonNode cweNode = cwesNode.get(0);
                if (cweNode.has("cweId")) {
                    cweId = cweNode.get("cweId").asText();
                }
            }
            
            return Vulnerability.builder()
                .id(ghsaId)
                .source(VulnerabilitySource.GITHUB)
                .title(summary)
                .description(description)
                .severity(severity)
                .affectedVersions(affectedVersions)
                .versionRange(versionRange)
                .references(references)
                .aliases(aliases)
                .publishedAt(publishedAt)
                .updatedAt(updatedAt)
                .cweId(cweId)
                .cvssScore(cvssScore)
                .cvssVector(cvssVector)
                .build();
                
        } catch (Exception e) {
            logger.warn("Failed to parse GitHub advisory: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Extracts severity from GitHub advisory data.
     */
    private Severity extractSeverity(JsonNode advisoryNode) {
        // Try CVSS score first
        JsonNode cvssNode = advisoryNode.get("cvss");
        if (cvssNode != null && cvssNode.has("score")) {
            double score = cvssNode.get("score").asDouble();
            return Severity.fromCvssScore(score);
        }
        
        // Fall back to severity field
        if (advisoryNode.has("severity")) {
            String severityStr = advisoryNode.get("severity").asText().toUpperCase();
            try {
                return Severity.valueOf(severityStr);
            } catch (IllegalArgumentException e) {
                // Fall through to default
            }
        }
        
        // Default to medium if no severity information
        return Severity.MEDIUM;
    }
    
    /**
     * Checks if a vulnerability entry is relevant to our dependency.
     */
    private boolean isVulnerabilityRelevant(JsonNode vulnNode, DependencyCoordinate dependency) {
        if (!vulnNode.has("package")) {
            return false;
        }
        
        JsonNode packageNode = vulnNode.get("package");
        String packageName = packageNode.has("name") ? packageNode.get("name").asText() : "";
        String ecosystem = packageNode.has("ecosystem") ? packageNode.get("ecosystem").asText() : "";
        
        String expectedPackageName = dependency.groupId() + ":" + dependency.artifactId();
        String expectedEcosystem = getGitHubEcosystem(dependency.buildTool());
        
        return expectedPackageName.equals(packageName) && expectedEcosystem.equals(ecosystem);
    }
    
    /**
     * Parses GitHub version range format.
     */
    private VersionRange parseGitHubVersionRange(String rangeStr) {
        try {
            // GitHub uses various formats like ">= 1.0.0, < 2.0.0"
            if (rangeStr.contains(",")) {
                String[] parts = rangeStr.split(",");
                String minPart = parts[0].trim();
                String maxPart = parts[1].trim();
                
                String minVersion = extractVersionFromPart(minPart);
                boolean includeMin = minPart.startsWith(">=");
                
                String maxVersion = extractVersionFromPart(maxPart);
                boolean includeMax = maxPart.startsWith("<=");
                
                if (minVersion != null && maxVersion != null) {
                    return VersionRange.between(minVersion, maxVersion, includeMax);
                } else if (minVersion != null) {
                    return VersionRange.minimum(minVersion);
                } else if (maxVersion != null) {
                    return VersionRange.maximum(maxVersion, includeMax);
                }
            } else if (rangeStr.startsWith(">=")) {
                String version = extractVersionFromPart(rangeStr);
                if (version != null) {
                    return VersionRange.minimum(version);
                }
            } else if (rangeStr.startsWith("<")) {
                String version = extractVersionFromPart(rangeStr);
                boolean include = rangeStr.startsWith("<=");
                if (version != null) {
                    return VersionRange.maximum(version, include);
                }
            }
            
        } catch (Exception e) {
            logger.debug("Failed to parse GitHub version range '{}': {}", rangeStr, e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Extracts version number from a version range part.
     */
    private String extractVersionFromPart(String part) {
        try {
            if (part.startsWith(">=")) {
                return part.substring(2).trim();
            } else if (part.startsWith("<=")) {
                return part.substring(2).trim();
            } else if (part.startsWith("<")) {
                return part.substring(1).trim();
            } else if (part.startsWith(">")) {
                return part.substring(1).trim();
            } else if (part.startsWith("=")) {
                return part.substring(1).trim();
            } else {
                return part.trim();
            }
        } catch (Exception e) {
            return null;
        }
    }
}
