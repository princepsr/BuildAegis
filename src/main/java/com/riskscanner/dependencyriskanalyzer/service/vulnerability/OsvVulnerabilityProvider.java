package com.riskscanner.dependencyriskanalyzer.service.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.riskscanner.dependencyriskanalyzer.model.DependencyCoordinate;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Severity;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.Vulnerability;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VulnerabilitySource;
import com.riskscanner.dependencyriskanalyzer.model.vulnerability.VersionRange;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

/**
 * OSV (Open Source Vulnerability) vulnerability provider.
 *
 * <p>Queries the OSV API for vulnerability information using package coordinates.
 * OSV provides aggregated vulnerability data from multiple sources with structured
 * version ranges and ecosystem-specific information.
 */
@Component
public class OsvVulnerabilityProvider implements VulnerabilityProvider {

    private static final Logger logger = LoggerFactory.getLogger(OsvVulnerabilityProvider.class);
    
    private static final String OSV_API_BASE = "https://api.osv.dev/v1/query";
    private static final String OSV_VULN_API = "https://api.osv.dev/v1/vulns/";
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    public OsvVulnerabilityProvider() {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }
    
    @Override
    public VulnerabilitySource getSource() {
        return VulnerabilitySource.OSV;
    }
    
    @Override
    public List<Vulnerability> getVulnerabilities(DependencyCoordinate dependency) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            // Build OSV query
            OsvQuery query = new OsvQuery(dependency);
            String requestBody = objectMapper.writeValueAsString(query);
            
            logger.debug("Querying OSV for dependency: {}", dependency);
            
            // Make API request
            String response = restTemplate.postForObject(OSV_API_BASE, requestBody, String.class);
            
            if (response != null) {
                JsonNode responseNode = objectMapper.readTree(response);
                JsonNode vulnsNode = responseNode.get("vulns");
                
                if (vulnsNode != null && vulnsNode.isArray()) {
                    for (JsonNode vulnNode : vulnsNode) {
                        try {
                            Vulnerability vulnerability = parseVulnerability(vulnNode, dependency);
                            if (vulnerability != null) {
                                vulnerabilities.add(vulnerability);
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to parse OSV vulnerability: {}", e.getMessage());
                        }
                    }
                }
            }
            
            logger.info("Found {} vulnerabilities from OSV for {}", vulnerabilities.size(), dependency);
            
        } catch (Exception e) {
            logger.error("Failed to query OSV for dependency {}: {}", dependency, e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    @Override
    public boolean supportsOffline() {
        return false; // OSV requires network access
    }
    
    @Override
    public int getPriority() {
        return 1; // High priority - comprehensive and up-to-date
    }
    
    @Override
    public boolean isHealthy() {
        try {
            // Simple health check - try to query a known package
            OsvQuery query = new OsvQuery("pkg:maven/org.apache.commons/commons-lang3@3.12.0");
            String requestBody = objectMapper.writeValueAsString(query);
            String response = restTemplate.postForObject(OSV_API_BASE, requestBody, String.class);
            return response != null && !response.contains("\"error\"");
        } catch (Exception e) {
            logger.debug("OSV health check failed: {}", e.getMessage());
            return false;
        }
    }
    
    @Override
    public String getDescription() {
        return "Open Source Vulnerability Database provider with comprehensive vulnerability data";
    }
    
    /**
     * Parses a vulnerability from OSV API response.
     */
    private Vulnerability parseVulnerability(JsonNode vulnNode, DependencyCoordinate dependency) {
        try {
            String id = vulnNode.get("id").asText();
            
            // Extract summary/title
            String title = vulnNode.has("summary") ? vulnNode.get("summary").asText() : id;
            
            // Extract description
            String description = vulnNode.has("details") ? vulnNode.get("details").asText() : "";
            
            // Extract severity
            Severity severity = extractSeverity(vulnNode);
            
            // Extract version information
            List<String> affectedVersions = new ArrayList<>();
            VersionRange versionRange = null;
            
            JsonNode affectedNode = vulnNode.get("affected");
            if (affectedNode != null && affectedNode.isArray()) {
                for (JsonNode affected : affectedNode) {
                    // Check if this affects our package
                    if (isPackageAffected(affected, dependency)) {
                        // Extract affected versions
                        JsonNode versionsNode = affected.get("versions");
                        if (versionsNode != null && versionsNode.isArray()) {
                            for (JsonNode versionNode : versionsNode) {
                                affectedVersions.add(versionNode.asText());
                            }
                        }
                        
                        // Extract version ranges
                        JsonNode rangesNode = affected.get("ranges");
                        if (rangesNode != null && rangesNode.isArray()) {
                            for (JsonNode rangeNode : rangesNode) {
                                if ("SEMVER".equals(rangeNode.get("type").asText())) {
                                    versionRange = extractVersionRange(rangeNode);
                                    break; // Use first range found
                                }
                            }
                        }
                    }
                }
            }
            
            // Extract references
            List<String> references = new ArrayList<>();
            JsonNode referencesNode = vulnNode.get("references");
            if (referencesNode != null && referencesNode.isArray()) {
                for (JsonNode refNode : referencesNode) {
                    if (refNode.has("url")) {
                        references.add(refNode.get("url").asText());
                    }
                }
            }
            
            // Extract aliases (CVEs, etc.)
            List<String> aliases = new ArrayList<>();
            JsonNode aliasesNode = vulnNode.get("aliases");
            if (aliasesNode != null && aliasesNode.isArray()) {
                for (JsonNode aliasNode : aliasesNode) {
                    aliases.add(aliasNode.asText());
                }
            }
            
            // Extract timestamps
            Instant publishedAt = null;
            Instant updatedAt = null;
            
            if (vulnNode.has("published")) {
                publishedAt = Instant.parse(vulnNode.get("published").asText());
            }
            
            if (vulnNode.has("modified")) {
                updatedAt = Instant.parse(vulnNode.get("modified").asText());
            }
            
            // Extract CVSS score
            Double cvssScore = null;
            String cvssVector = null;
            
            JsonNode severityNode = vulnNode.get("severity");
            if (severityNode != null && severityNode.isArray()) {
                for (JsonNode sevNode : severityNode) {
                    if (sevNode.has("score")) {
                        cvssScore = sevNode.get("score").asDouble();
                        if (sevNode.has("vector")) {
                            cvssVector = sevNode.get("vector").asText();
                        }
                        break;
                    }
                }
            }
            
            // Extract CWE ID
            String cweId = null;
            JsonNode databaseSpecificNode = vulnNode.get("database_specific");
            if (databaseSpecificNode != null && databaseSpecificNode.has("cwe")) {
                cweId = databaseSpecificNode.get("cwe").asText();
            }
            
            return Vulnerability.builder()
                .id(id)
                .source(VulnerabilitySource.OSV)
                .title(title)
                .description(description)
                .severity(severity)
                .affectedVersions(affectedVersions)
                .versionRange(versionRange)
                .references(references)
                .aliases(aliases)
                .publishedAt(publishedAt)
                .updatedAt(updatedAt)
                .cweId(cweId)
                .cvssScore(cvssScore)
                .cvssVector(cvssVector)
                .build();
                
        } catch (Exception e) {
            logger.warn("Failed to parse OSV vulnerability: {}", e.getMessage());
            return null;
        }
    }
    
    /**
     * Extracts severity from OSV vulnerability data.
     */
    private Severity extractSeverity(JsonNode vulnNode) {
        // Try to get CVSS score first
        JsonNode severityNode = vulnNode.get("severity");
        if (severityNode != null && severityNode.isArray()) {
            for (JsonNode sevNode : severityNode) {
                if (sevNode.has("score")) {
                    double score = sevNode.get("score").asDouble();
                    return Severity.fromCvssScore(score);
                }
            }
        }
        
        // Fall back to database_specific severity if available
        JsonNode databaseSpecificNode = vulnNode.get("database_specific");
        if (databaseSpecificNode != null && databaseSpecificNode.has("severity")) {
            String severityStr = databaseSpecificNode.get("severity").asText().toUpperCase();
            try {
                return Severity.valueOf(severityStr);
            } catch (IllegalArgumentException e) {
                // Fall through to default
            }
        }
        
        // Default to medium if no severity information
        return Severity.MEDIUM;
    }
    
    /**
     * Checks if the affected entry matches our dependency.
     */
    private boolean isPackageAffected(JsonNode affected, DependencyCoordinate dependency) {
        if (!affected.has("package")) {
            return false;
        }
        
        JsonNode packageNode = affected.get("package");
        String purl = packageNode.has("purl") ? packageNode.get("purl").asText() : "";
        
        // Convert our dependency to PURL format for comparison
        String expectedPurl = String.format("pkg:%s/%s/%s", 
            dependency.buildTool(), 
            dependency.groupId(), 
            dependency.artifactId());
        
        return purl.startsWith(expectedPurl);
    }
    
    /**
     * Extracts version range from OSV range data.
     */
    private VersionRange extractVersionRange(JsonNode rangeNode) {
        try {
            JsonNode eventsNode = rangeNode.get("events");
            if (eventsNode == null || !eventsNode.isArray()) {
                return null;
            }
            
            String minVersion = null;
            String maxVersion = null;
            boolean includeMin = false;
            boolean includeMax = false;
            
            for (JsonNode eventNode : eventsNode) {
                if (eventNode.has("introduced")) {
                    String introduced = eventNode.get("introduced").asText();
                    if (!"0".equals(introduced)) {
                        minVersion = introduced;
                        includeMin = true;
                    }
                } else if (eventNode.has("fixed")) {
                    maxVersion = eventNode.get("fixed").asText();
                    includeMax = false; // Fixed versions are exclusive
                } else if (eventNode.has("last_affected")) {
                    maxVersion = eventNode.get("last_affected").asText();
                    includeMax = true; // Last affected versions are inclusive
                }
            }
            
            if (minVersion != null && maxVersion != null) {
                return VersionRange.between(minVersion, maxVersion, includeMax);
            } else if (minVersion != null) {
                return VersionRange.minimum(minVersion);
            } else if (maxVersion != null) {
                return VersionRange.maximum(maxVersion, includeMax);
            }
            
        } catch (Exception e) {
            logger.debug("Failed to extract version range: {}", e.getMessage());
        }
        
        return null;
    }
    
    /**
     * OSV query request structure.
     */
    private static class OsvQuery {
        private final String packageType;
        private final String packageName;
        private final String ecosystem;
        
        public OsvQuery(DependencyCoordinate dependency) {
            this.ecosystem = dependency.buildTool();
            this.packageType = "maven"; // OSV uses "maven" for Maven packages
            this.packageName = dependency.groupId() + ":" + dependency.artifactId();
        }
        
        public OsvQuery(String purl) {
            // For PURL-based queries
            this.ecosystem = null;
            this.packageType = null;
            this.packageName = null;
        }
        
        // Getters for JSON serialization
        public String getPackage() {
            return packageName;
        }
        
        public String getEcosystem() {
            return ecosystem;
        }
        
        public String getPackage_type() {
            return packageType;
        }
    }
}
