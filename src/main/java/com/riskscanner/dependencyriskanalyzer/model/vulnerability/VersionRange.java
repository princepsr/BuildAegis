package com.riskscanner.dependencyriskanalyzer.model.vulnerability;

import java.util.Objects;

/**
 * Represents a version range for vulnerability matching.
 *
 * <p>Supports various version range formats including:
 * <ul>
 *   <li>Semantic version ranges (>=1.0.0,<2.0.0)</li>
 *   <li>Exact versions (=1.2.3)</li>
 *   <li>Minimum versions (>=1.0.0)</li>
 *   <li>Maximum versions (<2.0.0)</li>
 * </ul>
 */
public class VersionRange {
    
    private final String rangeExpression;
    private final RangeType type;
    private final String minVersion;
    private final String maxVersion;
    private final boolean includeMin;
    private final boolean includeMax;
    
    private VersionRange(String rangeExpression, RangeType type, String minVersion, String maxVersion, 
                       boolean includeMin, boolean includeMax) {
        this.rangeExpression = rangeExpression;
        this.type = type;
        this.minVersion = minVersion;
        this.maxVersion = maxVersion;
        this.includeMin = includeMin;
        this.includeMax = includeMax;
    }
    
    /**
     * Creates a version range from a range expression.
     * 
     * @param rangeExpression the range expression (e.g., ">=1.0.0,<2.0.0")
     * @return VersionRange instance
     */
    public static VersionRange fromExpression(String rangeExpression) {
        if (rangeExpression == null || rangeExpression.isBlank()) {
            throw new IllegalArgumentException("Range expression cannot be null or blank");
        }
        
        // Parse common range formats
        if (rangeExpression.startsWith(">=") && rangeExpression.contains(",")) {
            // Format: >=1.0.0,<2.0.0
            String[] parts = rangeExpression.split(",");
            String min = parts[0].substring(2);
            String maxPart = parts[1];
            boolean includeMax = !maxPart.startsWith(">");
            String max = maxPart.substring(includeMax ? 1 : 2);
            
            return new VersionRange(rangeExpression, RangeType.RANGE, min, max, true, includeMax);
        } else if (rangeExpression.startsWith(">=")) {
            // Format: >=1.0.0
            String min = rangeExpression.substring(2);
            return new VersionRange(rangeExpression, RangeType.MINIMUM, min, null, true, false);
        } else if (rangeExpression.startsWith("<")) {
            // Format: <2.0.0 or <=2.0.0
            boolean includeMax = rangeExpression.startsWith("<=");
            String max = rangeExpression.substring(includeMax ? 2 : 1);
            return new VersionRange(rangeExpression, RangeType.MAXIMUM, null, max, false, includeMax);
        } else if (rangeExpression.startsWith("=")) {
            // Format: =1.2.3
            String version = rangeExpression.substring(1);
            return new VersionRange(rangeExpression, RangeType.EXACT, version, version, true, true);
        } else {
            // Assume exact version if no operator
            return new VersionRange("=" + rangeExpression, RangeType.EXACT, rangeExpression, rangeExpression, true, true);
        }
    }
    
    /**
     * Creates an exact version range.
     */
    public static VersionRange exact(String version) {
        return new VersionRange("=" + version, RangeType.EXACT, version, version, true, true);
    }
    
    /**
     * Creates a minimum version range.
     */
    public static VersionRange minimum(String minVersion) {
        return new VersionRange(">=" + minVersion, RangeType.MINIMUM, minVersion, null, true, false);
    }
    
    /**
     * Creates a maximum version range.
     */
    public static VersionRange maximum(String maxVersion, boolean inclusive) {
        String expr = inclusive ? "<=" + maxVersion : "<" + maxVersion;
        return new VersionRange(expr, RangeType.MAXIMUM, null, maxVersion, false, inclusive);
    }
    
    /**
     * Creates a range between two versions.
     */
    public static VersionRange between(String minVersion, String maxVersion, boolean includeMax) {
        String expr = ">=" + minVersion + "," + (includeMax ? "<=" : "<") + maxVersion;
        return new VersionRange(expr, RangeType.RANGE, minVersion, maxVersion, true, includeMax);
    }
    
    /**
     * Checks if the given version is included in this range.
     * 
     * @param version the version to check
     * @return true if version is in range, false otherwise
     */
    public boolean includes(String version) {
        if (version == null || version.isBlank()) {
            return false;
        }
        
        return switch (type) {
            case EXACT -> version.equals(minVersion);
            case MINIMUM -> compareVersions(version, minVersion) >= (includeMin ? 0 : 1);
            case MAXIMUM -> compareVersions(version, maxVersion) <= (includeMax ? 0 : -1);
            case RANGE -> compareVersions(version, minVersion) >= (includeMin ? 0 : 1) &&
                         compareVersions(version, maxVersion) <= (includeMax ? 0 : -1);
        };
    }
    
    /**
     * Compares two version strings using semantic versioning rules.
     * 
     * @param v1 first version
     * @param v2 second version
     * @return negative if v1 < v2, zero if v1 == v2, positive if v1 > v2
     */
    private int compareVersions(String v1, String v2) {
        String[] parts1 = v1.split("\\.");
        String[] parts2 = v2.split("\\.");
        
        int maxLength = Math.max(parts1.length, parts2.length);
        
        for (int i = 0; i < maxLength; i++) {
            int num1 = i < parts1.length ? parseVersionPart(parts1[i]) : 0;
            int num2 = i < parts2.length ? parseVersionPart(parts2[i]) : 0;
            
            if (num1 != num2) {
                return Integer.compare(num1, num2);
            }
        }
        
        return 0;
    }
    
    /**
     * Parses a version part, handling numeric and non-numeric components.
     */
    private int parseVersionPart(String part) {
        try {
            // Extract numeric part at the beginning
            StringBuilder numeric = new StringBuilder();
            for (char c : part.toCharArray()) {
                if (Character.isDigit(c)) {
                    numeric.append(c);
                } else {
                    break;
                }
            }
            
            if (numeric.length() > 0) {
                return Integer.parseInt(numeric.toString());
            } else {
                // Non-numeric parts get lower priority than numeric parts
                return -1;
            }
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    
    // Getters
    public String getRangeExpression() {
        return rangeExpression;
    }
    
    public RangeType getType() {
        return type;
    }
    
    public String getMinVersion() {
        return minVersion;
    }
    
    public String getMaxVersion() {
        return maxVersion;
    }
    
    public boolean isIncludeMin() {
        return includeMin;
    }
    
    public boolean isIncludeMax() {
        return includeMax;
    }
    
    @Override
    public String toString() {
        return rangeExpression;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        VersionRange that = (VersionRange) o;
        return rangeExpression.equals(that.rangeExpression);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(rangeExpression);
    }
    
    /**
     * Type of version range.
     */
    public enum RangeType {
        EXACT,    // =1.2.3
        MINIMUM,  // >=1.0.0
        MAXIMUM,  // <2.0.0 or <=2.0.0
        RANGE     // >=1.0.0,<2.0.0
    }
}
